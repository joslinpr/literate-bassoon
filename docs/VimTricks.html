<!DOCTYPE html>
<html lang="en-US" style="scroll-behavior: auto; "> <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet"
           href="https://fonts.googleapis.com/css2?family=Playfair&family=Playfair%20Display&family=Crimson+Pro&family=Literata"
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<style>
a { color: blue;  background-color: rgb(230 230 240 / 50%); }
a:visited { color: green;  background-color: rgb(230 230 240 / 50%); }
blockquote { background-color:  rgb(230 230 240 / 50%); color: blue; }
body { background-color: #fdfdfd; color: black; font-family: 'Playfair',
    'Georgia', Serif; font-size: 16px}
code { background-color:  #f5f5f5; color: black; }
div { color: blue; }
em { color: blue; }
h1,h2 { border: 1px solid; font-size: 48px; text-align: center; }
h3,h4,h5,h6,{border-bottom: 1px solid;}
h1,h2,h3,h4,h5,h6 { color: blue;  background-color: #e5effb; font-family: "Playfair Display", Playfair, Verdana, Serif;}
head { color: blue;  background-color: #e5effb;}
hr { color: blue; }
img { color: blue; border: 1px solid rgba(0, 0, 0, 0.8);}
li { color: blue; }
ol { color: blue; }
pre { background-color:  #f5f5f5; color: black; }
span { color: blue; }
strong { color: blue; }
style { color: blue; }
table { color: blue; border: 1px solid rgba(0, 0, 0, 0.8);}
tbody { color: blue; }
td { color: blue; border-right: 1px solid; border-bottom: 1px solid; }
th { color: black;
    border: 1px solid rgba(0, 0, 0, 0.8);
    background-color: #e5effb;}
thead { color: blue; }
tr { color: blue; }
ul { color: blue; }
.toc { background-color: wheat; border: brown 1px solid;}
</style>
</head>
<body> <!-- vim: set ai si nu :-->
<h2>Table of Contents</h2>
<h2>VimTricks.md</h2>
<h2>Vim Tips and Tricks</h2>
<h3>Using Vim as a Pipe:</h3>
<pre><code>vim - -es +'g/foo/p' +'qa!' --not-a-term
vim &lt; /dev/tty &lt;(cat)
</code></pre>
<h3>Simple Math</h3>
<pre><code>CTRL-A - increment number under cursor
CTRL-X - decrement number under cursor
</code></pre>
<h3>Bouncing</h3>
<pre><code>Matchit - use g% to find next/previous match
          use % to find match to construct under cursor (if, (, ), {, } etc.
</code></pre>
<h3>Checking Variables</h3>
<pre><code>:verbose set variable?
OR
:echo &quot;Variable:&quot; &amp;variable
</code></pre>
<h3>Changing Case</h3>
<pre><code>g&lt;change&gt;&lt;motion&gt;
 g = go
 *change* = U Upper, u Lower, ~ Invert
 Doubled *change* means &quot;entire line&quot;
 *motion* = G end of Document, j Line Above, w Word
</code></pre>
<h4>Examples</h4>
<table>
<thead>
<tr>
<th>Command</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td>~</td>
<td>Changes the case of current character</td>
</tr>
<tr>
<td>guu</td>
<td>Change current line from upper to lower.</td>
</tr>
<tr>
<td>gUU</td>
<td>Change current LINE from lower to upper.</td>
</tr>
<tr>
<td>guw</td>
<td>Change to end of current WORD from upper to lower.</td>
</tr>
<tr>
<td>guaw</td>
<td>Change all of current WORD to lower.</td>
</tr>
<tr>
<td>gUw</td>
<td>Change to end of current WORD from lower to upper.</td>
</tr>
<tr>
<td>gUaw</td>
<td>Change all of current WORD to upper.</td>
</tr>
<tr>
<td>g~~</td>
<td>Invert case to entire line</td>
</tr>
<tr>
<td>g~w</td>
<td>Invert case to current WORD</td>
</tr>
<tr>
<td>guG</td>
<td>Change to lowercase until the end of document.</td>
</tr>
<tr>
<td>gU)</td>
<td>Change until end of sentence to upper case</td>
</tr>
<tr>
<td>gu}</td>
<td>Change to end of paragraph to lower case</td>
</tr>
<tr>
<td>gU5j</td>
<td>Change 5 lines below to upper case</td>
</tr>
<tr>
<td>gu3k</td>
<td>Change 3 lines above to lower case</td>
</tr>
</tbody>
</table>
<h3>Non-breaking Space</h3>
<p>To find out the character code of the non-breaking space, place the
cursor over it and type use the normal mode command <code>ga</code>. Vim will
display a legend at the bottom. Note the hex representation. If the hex
representation is 00a0, then you could execute the following command to
do the substitution:</p>
<pre><code>    :%s/\%u00a0/\~/g
</code></pre>
<h3>Spelling</h3>
<p>To turn on spelling:  <code>:setlocal spell spelllang=en_us</code></p>
<h4>Highlighting</h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
<th>Highlight</th>
</tr>
</thead>
<tbody>
<tr>
<td>SpellBad</td>
<td>word not recognized</td>
<td>hl-SpellBad</td>
</tr>
<tr>
<td>SpellCap</td>
<td>word not capitalised</td>
<td>hl-SpellCap</td>
</tr>
<tr>
<td>SpellRare</td>
<td>rare word</td>
<td>hl-SpellRare</td>
</tr>
<tr>
<td>SpellLocal</td>
<td>wrong spelling for selected region</td>
<td>hl-SpellLocal</td>
</tr>
</tbody>
</table>
<h4>Searching for Misspellings</h4>
<table>
<thead>
<tr>
<th>Command</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>]s</em></td>
<td>Move to next misspelled word after the cursor. A count before the command can be used to repeat. &lsquo;wrapscan&rsquo; applies.</td>
</tr>
<tr>
<td><em>[s</em></td>
<td>Like <em>]s</em> but search backwards, find the misspelled word before the cursor.  Doesn&rsquo;t recognize words split over two lines, thus may stop at words that are not highlighted as bad.  Does not stop at word with missing capital at the start of a line.</td>
</tr>
<tr>
<td><em>]S</em></td>
<td>Like <em>]s</em> but only stop at bad words, not at rare words or words for another region.</td>
</tr>
<tr>
<td><em>[S</em></td>
<td>Like <em>]S</em> but search backwards.</td>
</tr>
</tbody>
</table>
<h4>To add words to your own word list:</h4>
<table>
<thead>
<tr>
<th>Command</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>zg</em></td>
<td>Add word under the cursor as a good word to the first name in &lsquo;spellfile&rsquo;.  A count may precede the command to indicate the entry in &lsquo;spellfile&rsquo; to be used.  A count of two uses the second entry.</td>
</tr>
<tr>
<td><em>zw</em></td>
<td>Like &ldquo;zg&rdquo; but mark the word as a wrong (bad) word. If the word already appears in &lsquo;spellfile&rsquo; it is turned into a comment line.</td>
</tr>
<tr>
<td><em>zug</em> <em>zuw</em></td>
<td>Undo <em>zw</em> and <em>zg</em>, remove the word from the entry in &lsquo;spellfile&rsquo;.</td>
</tr>
</tbody>
</table>
<h4>Finding suggestions for bad words:</h4>
<table>
<thead>
<tr>
<th>Command</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>z=</em></td>
<td>For the word under/after the cursor suggest correctly spelled words.  This also works to find alternatives for a word that is not highlighted as a bad word, e.g., when the word after it is bad. In Visual mode the highlighted text is taken as the word to be replaced. The results are sorted on similarity to the word being replaced. This may take a long time.  Hit CTRL-C when you get bored.</td>
</tr>
<tr>
<td><em>CTRL-Xs</em></td>
<td>In Insert mode, when the cursor is after a badly spelled word, you can use CTRL-X s to find suggestions.  This works like Insert mode completion.  Use CTRL-N to use the next suggestion, CTRL-P to go back.</td>
</tr>
</tbody>
</table></body> </html> <!-- vim: set ai si nu :-->
